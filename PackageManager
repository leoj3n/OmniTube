#!/usr/bin/env python
#-*- coding:UTF-8 -*-
#
# @author  Ritashugisha
# @contact ritashugisha@gmail.com
#
# This file is part of PackageManager.
#
# PackageManager is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# PackageManager is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with PackageManager. If not, see <http://www.gnu.org/licenses/>.

"""
.. module:: PackageManager
	:platform: OSX
	:synopsis: Alfred workflow useful executable repository manager.

.. moduleauthor:: Ritashugisha <ritashugisha@gmail.com>
"""
import os, sys, subprocess
import inspect, StringIO
import json, urllib, tempfile
import argparse, traceback

MAIN_JSON = 'https://raw.github.com/Ritashugisha/AlfredWorkflowResourcePack/master/main.json'

"""
.. py:function:: __runProcess__(procCmd)
Run a subprocess on the system.

:param str procCmd: command to be run as subprocess
:returns: output of the subprocess
:rtype: str
"""
def __runProcess__(procCmd):
	proc = subprocess.Popen([procCmd], stdout = subprocess.PIPE, shell = True)
	(proc, proc_e) = proc.communicate()
	return proc

"""
.. py:function:: onError(header, message)
Display an error message to the console then exit system.

:param str header: error type
:param str message: message linked to error
"""	
def onError(header, message):
	sys.stdout.write('\033[31m\033[1m%s:\033[0m %s\n' % (header, message))
	sys.exit(0)

"""
.. py:function:: onWarning(header, message)
Display a warning message to the console.

:param str header: warning type
:param str message: message linked to warning
"""	
def onWarning(header, message):
	sys.stdout.write('\033[33m\033[1m%s:\033[0m %s\n' % (header, message))

"""
.. py:function:: onVerbose(message, display)
Display a verbose formatted message to the console.

:param str message: message to be displayed
:param bool display: if true, display the message
"""
def onVerbose(message, display):
	if display:
		info = inspect.getframeinfo(inspect.stack()[1][0])
		header = '%s<%s@%s>' % (os.path.basename(__file__), info.function, info.lineno)
		sys.stdout.write('%s%s%s\n' % (header, ' ' * (40 - len(header)), message))


"""
.. py:class:: PackageManager()
Alfred workflow resource dependency package manager.
"""
class PackageManager():
	
	"""
	.. py:function:: __init__(self, requiredDependencies = [], verbose = False)
	Initialize the PackageManager object, configure, and install dependencies.
	
	:param list requiredDependencies: list of dictionaries formatted as such ``{'title':'TITLE_OF_PKG', 'dest':'PATH_TO_SAVE'}``
	:param bool verbose: true if verbose output is allowed
	""" 
	def __init__(self, requiredDependencies = [], verbose = False):
		self.requiredDependencies = requiredDependencies
		self.verbose   = verbose
		onVerbose('reading JSON from <%s>' % MAIN_JSON, self.verbose)
		self.jsonRead  = json.loads(urllib.urlopen(MAIN_JSON).read())
		self.author    = self.jsonRead['author']
		self.contact   = self.jsonRead['contact']
		self.version   = self.jsonRead['version']
		self.resources = self.jsonRead['resources']
		self.configure()
		self.installDependencies()
	
	"""
	.. py:function:: __str__(self)
	Return a string representation of the PackageManager object.
	
	:returns: PackageManager's representation
	:rtype: str
	"""
	def __str__(self):
		return '%s v%s by %s (%s)' % (os.path.basename(__file__), self.version, self.author, self.contact)
	
	"""
	.. py:function:: isValidQuery(self, dependency)
	Test if the passed dependency dictionary is formatted correctly.
	
	:param dict dependency: dictionary formatted as such ``{'title':'TITLE_OF_PKG', 'dest':'PATH_TO_SAVE'}``
	:returns: true if valid
	:rtype: bool
	"""
	def isValidQuery(self, dependency):
		result = False
		onVerbose('checking if "%s" is valid' % str({'title':dependency['title'], 
			'dest':dependency['dest']}), self.verbose)
		if isinstance(dependency, dict): 
			if 'title' in dependency and 'dest' in dependency:
				if len(dependency['title']) > 0 and len(dependency['dest']) > 0:
					result = True
		if not result:
			onWarning('MalformedQuery', dependency)
		return result
	
	"""
	.. py:function:: isDependency(self, dependency)
	Check if the passed dependency dictionary exists.
	
	:param dict dependency: dictionary formatted as such ``{'title':'TITLE_OF_PKG', 'dest':'PATH_TO_SAVE'}``
	:returns: true if valid
	:rtype: bool
	"""	
	def isDependency(self, dependency):
		result = False
		onVerbose('checking if "%s" is an actual dependency' % dependency['title'], self.verbose)
		for i in self.resources:
			if dependency['title'].lower() == i['title'].lower():
				result = True
		if not result:
			onWarning('InvalidDependency', dependency)
		return result
	
	"""
	.. py:function:: formatQuery(self, dependency)
	Reformat the passed dependency's dictionary destination if need be.
	
	:param dict dependency: dictionary formatted as such ``{'title':'TITLE_OF_PKG', 'dest':'PATH_TO_SAVE'}``
	:returns: formatted dependency dictionary
	:rtype: dict
	"""
	def formatQuery(self, dependency):
		if self.isValidQuery(dependency):
			if dependency['dest'][-1] == '/':
				dependency['dest'] = dependency['dest'][:-1]
			if dependency['dest'][0] != '/':
				dependency['dest'] = '/%s' % dependency['dest']
			onVerbose('reformatted %s\'s dest to "%s"' % (dependency['title'], dependency['dest']), self.verbose)
			return dependency
	
	"""
	.. py:function:: linkDependency(self, dependency)
	Add the items of the remote dependency dictionary to the local one.
	
	:param dict dependency: dictionary formatted as such ``{'title':'TITLE_OF_PKG', 'dest':'PATH_TO_SAVE'}``
	:returns: formatted dependency dictionary
	:rtype: dict
	"""
	def linkDependency(self, dependency):
		if self.isValidQuery(dependency) and self.isDependency(dependency):
			dependency = self.formatQuery(dependency)
			onVerbose('linking local and remote dependency keys for "%s"' % dependency['title'], self.verbose)
			for i in self.resources:
				if dependency['title'].lower() == i['title'].lower():
					for k, v in i.iteritems():
						dependency[k] = i[k]
			return dependency
		else:
			onError('UnexpectedError',
				'encountered error when trying to link <%s>' % dependency['title'])
	
	"""
	.. py:function:: isInstalled(self, dependency)
	Check if the dependency from the dependency dictionary already exists at the destination.
	
	:param dict dependency: dictionary formatted as such ``{'title':'TITLE_OF_PKG', 'dest':'PATH_TO_SAVE'}``
	:returns: true if dependency exists at destination
	:rtype: bool
	"""
	def isInstalled(self, dependency):
		if len(dependency) < 3:
			dependency = self.linkDependency(dependency)
		onVerbose('checking if "%s" exists at "%s"' % (dependency['name'], dependency['dest']), self.verbose)
		return os.path.exists('%s/%s' % (dependency['dest'], dependency['name']))
	
	"""
	.. py:function:: isEqual(self, dependency)
	Check if the dependency installed at the destination is not outdated from the remote resource.
	
	:param dict dependency: dictionary formatted as such ``{'title':'TITLE_OF_PKG', 'dest':'PATH_TO_SAVE'}``
	:returns: true if version is not outdated
	:rtype: bool
	"""	
	def isEqual(self, dependency):
		result = False
		if self.isInstalled(self.linkDependency(dependency)):
			onVerbose('checking that "%s" is not outdated' % dependency['name'], self.verbose)
			execPath = '%s/%s' % (dependency['dest'], dependency['exec'])
			readBuffer = StringIO.StringIO()
			sys.stdout = readBuffer
			exec(str(dependency['bene'] % execPath))
			sys.stdout = sys.__stdout__
			try:
				result = float(readBuffer.getvalue()) >= float(dependency['version'])
			except ValueError:
				result = False
		else:
			onError('NotInstalled',
				'"%s" is not installed to "%s"' % (dependency['title'],
				dependency['dest']))
		return result
	
	"""
	.. py:function:: listDependencies(self)
	List all available dependencies from the remote json.
	"""
	def listDependencies(self):
		onVerbose('listing available dependencies', self.verbose)
		outString = '%s v%s - by %s\n' % (os.path.basename(__file__), self.version, self.author)
		for i in self.resources:
			outString = '%s{"title":"%s", "name":"%s", "version":"%s"}\n' % (outString, 
				i['title'], i['name'], i['version']) 
		return outString	
	
	"""
	.. py:function:: configure(self)
	Configure all of PackageManager's variables.
	"""
	def configure(self):
		onVerbose('configuring PackageManager\'s varaibles', self.verbose)
		for i in self.requiredDependencies:
			if not self.isDependency(i):
				self.requiredDependencies.remove(i)
			else:
				i = self.linkDependency(i)
		for i in self.requiredDependencies:
			if self.isInstalled(i):
				if self.isEqual(i):
					self.requiredDependencies.remove(i)
	
	"""
	.. py:function:: installDependencies(self)
	Try and install all valid and available dependencies.
	"""
	def installDependencies(self):
		try:
			for i in self.requiredDependencies:
				newSave = tempfile.mkstemp(suffix = '.zip', dir = '/tmp')
				newDownload = urllib.urlretrieve(i['raw'], newSave[1])
				onVerbose('downloading "%s" to "%s"' % (i['name'], newSave[1]), self.verbose)
				if not os.path.exists(i['dest']):
					__runProcess__('mkdir %s' % i['dest'].replace(' ', '\ '))
				onVerbose('installing "%s" to "%s"' % (i['name'], i['dest']), self.verbose)
				__runProcess__('unzip -o %s -d %s' % (newSave[1], i['dest'].replace(' ', '\ ')))
				__runProcess__('rm -rf %s' % newSave[1])
		except Exception as e:
			onError(type(e).__name__, e)


"""
.. py:function:: getUsage()
Return the usage string of the command-line help argument.

:returns: usage string of arugment parser
:rtype: str
"""
def getUsage():
	return '\n'.join(['%(prog)s',
		'\t[-h] [-i DEPENDENCIES...] [-o DESTINATIONS...]',
		'\t[--list-dependencies]',
		'\t[--is-installed TITLE DEST]',
		'\t[--is-outdated TITLE DEST]',
		'\t[--version]'])

"""
.. py:function:: logicArgs()
Parse valid command-line arguments for console use.
"""
def logicArgs():
	parser = argparse.ArgumentParser(description = 'Install required dependencies for AlfredApp workflows.',
		usage = getUsage())
	parser.add_argument('--version', dest = 'version', default = False,
		action = 'store_true', help = 'show version number')
	parser.add_argument('-v', '--verbose', dest = 'verbose', default = False,
		action = 'store_true', help = 'enable verbose output')
	parser.add_argument('-i', dest = 'dependencies', nargs = '*', 
		default = [], help = 'dependencies to install', metavar = 'PKG')
	parser.add_argument('-o', dest = 'destinations', nargs = '*',
		default = [], help = 'destination paths to place dependencies', metavar = 'DIR')
	parser.add_argument('--list-dependencies', dest = 'list', default = False, 
		action = 'store_true', help = 'list all available dependencies')
	parser.add_argument('--is-installed', dest = 'local', nargs = '*',
		default = [], help = argparse.SUPPRESS)
	parser.add_argument('--is-outdated', dest = 'dated', nargs = '*',
		default = [], help = argparse.SUPPRESS)
	args = parser.parse_args()
	if args.list:
		sys.stdout.write(PackageManager().listDependencies())
	elif args.local:
		if len(args.local) != 2:
			onError('ArgumentError',
				'arguments must be a set of two')
		sys.stdout.write('%s\n' % PackageManager().isInstalled({'title':args.local[0], 
			'dest':args.local[1]}))
	elif args.dated:
		if len(args.dated) != 2:
			onError('ArgumentError',
				'arguments must be a set of two')
		oudated = not PackageManager().isEqual({'title':args.dated[0], 
			'dest':args.dated[1]})
		sys.stdout.write('%s\n' % oudated)
	elif args.version:
		sys.stdout.write('%s\n' % PackageManager().version)
	else:
		if not args.dependencies or not args.destinations:
			onError('MissingArguments',
				'arguments -i and -o are required')
		if len(args.dependencies) != len(args.destinations):
			onError('NotEnoughArguments', 
				'malformed arguments to format destinations for dependencies')
		requiredDependencies = []
		for k, v in dict(zip(args.dependencies, args.destinations)).iteritems():
			requiredDependencies.append({'title':k, 'dest':v})
		PackageManager(requiredDependencies = requiredDependencies, verbose = args.verbose)
	
if __name__ in '__main__':
	logicArgs()
